Task * GPU,OMP,CPU;
# Task taco_validate CPU;
# region *taskname *region_name processor, list_of_memories;
Region * * * SOCKMEM,SYSMEM;
Region * * GPU FBMEM,ZCMEM;
# Region * * has_affinity CPU SOCKMEM,SYSMEM;
# Region * * has_affinity CPU SOCKMEM,SYSMEM;

# Task taco_validate parent_task_procesor;

# ZCMEM,FBMEM,SYSMEM,RDMEM
# Layout taskname regionname memory AOS F_order;
Layout * * * SOA C_order; # Align==128 Compact

# InstanceLimit task_1 OMP 10; # controlled by command line in TacoMapper

# CollectMemory * *;

# m1 = Machine(OMP); # nodes * OMP
# m2 = m1.balance_split(0, 2); # node1 * node2 * OMP
# m3 = m2.balance_split(2, 2); # node1 * node2 * OMP1(1) * OMP2(1)

m4 = Machine(GPU); # nodes * 4
m5 = m4.balance_split(0, 2); # node1 * node2 * 4
m6 = m5.balance_split(2, 2); # node1 * node2 * 2 * 2
m10 = m6.swap(0, 1);
m11 = m10.swap(2, 3);

m7 = m4.merge(0, 1);
# m8 = m4.balance_split(1, 2); # nodes * 2 * 2
# m9 = m8.swap(1, 2);

def block_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2)
{
    return x[dim1] * z.size[dim2] / y.size[dim1];
}

def cyclic_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2)
{
    return x[dim1] % z.size[dim2];
}

def block1d(IPoint x, ISpace y, MSpace z)
{
    return block_primitive(x, y, z, 0, 0);
}

def blockcyclic(IPoint x, ISpace y, MSpace z)
{
    a = block_primitive(x, y, z, 0, 0);
    b = block_primitive(x, y, z, 1, 1);
    c = cyclic_primitive(x, y, z, 0, 2);
    d = cyclic_primitive(x, y, z, 1, 3);
    return (a, b, c, d);
}

def cyclic2d(IPoint x, ISpace y, MSpace z)
{
    a = cyclic_primitive(x, y, z, 0, 0);
    b = cyclic_primitive(x, y, z, 1, 1);
    return (a, b);
}

-# def block3d(IPoint x, ISpace y, MSpace z)
-# {
-#     a = block_primitive(x, y, z, 0, 0);
-#     b = block_primitive(x, y, z, 1, 1);
-#     c = block_primitive(x, y, z, 2, 2);
-#     return (a, b, c);
-# }

IndexTaskMap * m11 blockcyclic;
IndexTaskMap task_1 m4 cyclic2d;
IndexTaskMap task_2 m4 cyclic2d;
IndexTaskMap task_3 m4 cyclic2d;
IndexTaskMap init_cublas m7 block1d;
