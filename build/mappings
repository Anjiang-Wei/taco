Task * GPU,OMP,CPU;
# Task taco_validate CPU;
Region * * GPU FBMEM,ZCMEM;
# region *taskname *region_name processor, list_of_memories;
Region * * OMP SOCKMEM,SYSMEM;
Region * * CPU SOCKMEM,SYSMEM;
# Region * * has_affinity CPU SOCKMEM,SYSMEM;
# Region * * has_affinity CPU SOCKMEM,SYSMEM;

# ZCMEM,FBMEM,SYSMEM,RDMEM
# Layout taskname regionname memory AOS F_order;
Layout * * * AOS F_order Align==128; # Compact

# InstanceLimit task_1 OMP 10; # controlled by command line in TacoMapper

# CollectMemory * *;

m1 = Machine(OMP); # or GPU
m2 = m1.merge(0, 1);
m3 = m2.balance_split(0, 3);

m4 = Machine(GPU);
m5 = m4.merge(0, 1);

def block_dim(IPoint x, ISpace y, MSpace z, int dim)
{
    a = x[dim];
    b = z.size[dim];
    c = y.size[dim];
    d = a * b / c;
    print("inside blockdim, {}, {}, {}, dim={} --> {}", a, b, c, dim, d);
    return x[dim] * z.size[dim] / y.size[dim];
}

def cyclic_dim(IPoint x, ISpace y, MSpace z, int dim)
{
    return x[dim] % z.size[dim];
}

def block1d(IPoint x, ISpace y, MSpace z)
{
    return block_dim(x, y, z, 0);
}

def block2d(IPoint x, ISpace y, MSpace z)
{
    a = block_dim(x, y, z, 0);
    b = block_dim(x, y, z, 1);
    print("block2d: {},{}", a, b);
    return (a, b);
}

def block3d(IPoint x, ISpace y, MSpace z)
{
    a = block_dim(x, y, z, 0);
    b = block_dim(x, y, z, 1);
    c = block_dim(x, y, z, 2);
    return (a, b, c);
}

def cyclic1d(IPoint x, ISpace y, MSpace z)
{
    return cyclic_dim(x, y, z, 0);
}

def cyclic2d(IPoint x, ISpace y, MSpace z)
{
    a = cyclic_dim(x, y, z, 0);
    b = cyclic_dim(x, y, z, 1);
    return (a, b);
}

IndexTaskMap * m1 block2d;
# IndexTaskMap * m4 block2d;
IndexTaskMap task_7 m1 block2d;
IndexTaskMap task_11 m1 block2d;
IndexTaskMap init_cublas m5 block1d;
