Task * GPU,OMP,CPU;
# Task taco_validate CPU;
# region *taskname *region_name processor, list_of_memories;
Region * * * SOCKMEM,SYSMEM;
Region * * GPU FBMEM,ZCMEM;
# Region * * has_affinity CPU SOCKMEM,SYSMEM;
# Region * * has_affinity CPU SOCKMEM,SYSMEM;

# Task taco_validate parent_task_procesor;

# ZCMEM,FBMEM,SYSMEM,RDMEM
# Layout taskname regionname memory AOS F_order;
Layout * * * SOA C_order; # Align==128 Compact

# InstanceLimit task_1 OMP 10; # controlled by command line in TacoMapper

# CollectMemory * *;

m1 = Machine(OMP); # nodes * OMP
m2 = m1.balance_split(0, 2); # node1 * node2 * OMP
m3 = m2.balance_split(2, 2); # node1 * node2 * OMP1(1) * OMP2(1)

m4 = Machine(GPU); # nodes * 4
m5 = m4.balance_split(0, 2); # node1 * node2 * 4
m6 = m5.balance_split(2, 2); # node1 * node2 * 2 * 2
m10 = m6.swap(0, 1);

m7 = m4.merge(0, 1);
m8 = m4.balance_split(1, 2); # nodes * 2 * 2
m9 = m8.swap(1, 2);

def block_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2)
{
    a = x[dim1];
    b = z.size[dim2];
    c = y.size[dim1];
    d = a * b / c;
    # print("inside blockdim, {}, {}, {}, dim={} --> {}", a, b, c, dim, d);
    return d;
}

def block1d(IPoint x, ISpace y, MSpace z)
{
    return block_primitive(x, y, z, 0, 0);
}

def blockwise(IPoint x, ISpace y, MSpace z)
{
    a = block_primitive(x, y, z, 0, 0);
    b = block_primitive(x, y, z, 1, 1);
    c = block_primitive(x, y, z, 0, 2);
    d = block_primitive(x, y, z, 1, 3);
    return (a, b, c, d);
}

def block3d(IPoint x, ISpace y, MSpace z)
{
    a = block_primitive(x, y, z, 0, 0);
    b = block_primitive(x, y, z, 1, 1);
    c = block_primitive(x, y, z, 2, 2);
    return (a, b, c);
}

IndexTaskMap * m10 blockwise;
IndexTaskMap task_1 m9 block3d;
IndexTaskMap task_2 m9 block3d;
IndexTaskMap task_3 m9 block3d;
IndexTaskMap init_cublas m7 block1d;
# IndexTaskMap task_7 m3 blockwise;
IndexTaskMap task_11 m3 blockwise;
