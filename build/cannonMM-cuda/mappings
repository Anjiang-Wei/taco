Task * GPU,OMP,CPU;
# Task taco_validate CPU;
# region $taskname $region_name $processor $list_of_memories;
Region * * * SOCKMEM,SYSMEM;
Region * * GPU FBMEM,ZCMEM;

# Other supported Memory: RDMEM

# Layout taskname regionname memory AOS F_order;
Layout * * * SOA C_order; # Align==128 Compact

# InstanceLimit task_5 * 10; # controlled by command line in TacoMapper
# InstanceLimit task_7 * 10; # controlled by command line in TacoMapper

CollectMemory task_5 *; # controlled by command line in TacoMapper

def block_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2) {
    return x[dim1] * z.size[dim2] / y.size[dim1];
}

def cyclic_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2) {
    return x[dim1] % z.size[dim2];
}

m_2d = Machine(GPU); # nodes * processors
m_1d = m_2d.merge(0, 1);

def auto2d(Task task) {
    m_3d = m_2d.auto_split(0, task.ispace); # split the original 0 dim into 0,1 dim
    # subspace: task.ispace / m_3d[:-1]
    m_4d = m_3d.auto_split(2, task.ispace / m_3d[:-1]); # split the processor (previosly 1, now 2) dim into 2,3 dim w.r.t subspace
    upper = tuple(block_primitive(task.ipoint, task.ispace, m_4d, i, i) for i in (0,1));
    lower = tuple(cyclic_primitive(task.ipoint, task.ispace, m_4d, i, i + 2) for i in (0,1));
    return m_4d[*upper, *lower];
}

def block1d(Task task) {
    return m_1d[block_primitive(task.ipoint, task.ispace, m_1d, 0, 0)];
}

m_omp_2d = Machine(OMP);

def auto2d_omp(Task task) {
    m_3d = m_omp_2d.auto_split(0, task.ispace); # split the original 0 dim into 0,1 dim
    # subspace: task.ispace / m_3d[:-1]
    m_4d = m_3d.auto_split(2, task.ispace / m_3d[:-1]); # split the processor (previosly 1, now 2) dim into 2,3 dim w.r.t subspace
    upper = tuple(block_primitive(task.ipoint, task.ispace, m_4d, i, i) for i in (0,1));
    lower = tuple(cyclic_primitive(task.ipoint, task.ispace, m_4d, i, i + 2) for i in (0,1));
    return m_4d[*upper, *lower];
}

# task_5: UNTRACK_VALID_REGIONS, BACKPRESSURE_TASK, always (2, 2) only for slicing, no sharding;
# 4nodes: gridX, gridY = 2, 2
IndexTaskMap * auto2d; # task_1, task_2, task_3: (gridX * 2, gridY * 2)
IndexTaskMap init_cublas block1d;
IndexTaskMap task_7 auto2d_omp; # task_7: (gridX, gridY)
# if only turn this on, and comment out all the above IndexTaskMap, then ~1.5X faster! Don't understand why yet.
# IndexTaskMap taco_fill m6 blockcyclic;
