Task * GPU,OMP,CPU;

Region * * * SOCKMEM,SYSMEM;
Region * * GPU FBMEM,ZCMEM;

# Layout taskname regionname memory AOS F_order;
Layout * * * SOA C_order; # Align==128 Compact

# InstanceLimit task_1 OMP 10; # controlled by command line in TacoMapper

CollectMemory * *;

m4 = Machine(GPU); # nodes * 4
# split the first dimension (i.e., nodes dimension) in as square as possible
m5 = m4.balance_split(0, 2); # node1 * node2 * 4 GPUs
# split the third dimension (i.e., processor dimension) as square as possible
m6 = m5.balance_split(2, 2); # node1 * node2 * 2 * 2
m6_ = m6.swap(0, 1);
m6__ = m6_.swap(2, 3);

m7 = m4.merge(0, 1);
# m8 = m4.balance_split(1, 2); # nodes * 2 * 2
# m9 = m8.swap(1, 2);

def block_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2)
{
    return x[dim1] * z.size[dim2] / y.size[dim1];
}

def cyclic_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2)
{
    return x[dim1] % z.size[dim2];
}

def block1d(IPoint x, ISpace y, MSpace z)
{
    return block_primitive(x, y, z, 0, 0);
}

def blockcyclic(IPoint x, ISpace y, MSpace z)
{
    a = block_primitive(x, y, z, 0, 0);
    b = block_primitive(x, y, z, 1, 1);
    c = cyclic_primitive(x, y, z, 0, 2);
    d = cyclic_primitive(x, y, z, 1, 3);
    return (a, b, c, d);
}

def block2d(IPoint x, ISpace y, MSpace z)
{
    a = block_primitive(x, y, z, 0, 0);
    b = block_primitive(x, y, z, 1, 1);
    return (a, b);
}

# 4nodes: rpoc=4, c=1
IndexTaskMap task_5 m6__ blockcyclic; # task_5: (rpoc, rpoc, c)
IndexTaskMap task_1 m4 block2d; # task_1, task_2, task_3: (rpoc, rpoc, 1)
IndexTaskMap task_2 m4 block2d; # task_{1,2,3} has PLACEMENT_SHARD tag... magic
IndexTaskMap task_3 m4 block2d;
IndexTaskMap init_cublas m7 block1d;
