Task * GPU,OMP,CPU;

Region * * * SOCKMEM,SYSMEM;
Region * * GPU FBMEM,ZCMEM;

# Layout taskname regionname memory AOS F_order;
Layout * * * SOA C_order; # Align==128 Compact

# InstanceLimit task_1 OMP 10; # controlled by command line in TacoMapper

CollectMemory * *;

m4 = Machine(GPU); # nodes * 4
m5 = m4.balance_split(0, 2); # node1 * node2 * 4
m6 = m5.swap(0, 1);

m7 = m4.merge(0, 1);
# m8 = m4.balance_split(1, 2); # nodes * 2 * 2
# m9 = m8.swap(1, 2);

def block_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2)
{
    return x[dim1] * z.size[dim2] / y.size[dim1];
}

def cyclic_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2)
{
    return x[dim1] % z.size[dim2];
}

def block1d(IPoint x, ISpace y, MSpace z)
{
    return block_primitive(x, y, z, 0, 0);
}

def blockwise(IPoint x, ISpace y, MSpace z)
{
    a = block_primitive(x, y, z, 0, 0);
    b = block_primitive(x, y, z, 1, 1);
    c = block_primitive(x, y, z, 0, 2);
    d = block_primitive(x, y, z, 0, 3);
    return (a, b, c, d);
}

def block2d(IPoint x, ISpace y, MSpace z)
{
    a = block_primitive(x, y, z, 0, 0);
    b = block_primitive(x, y, z, 1, 1);
    return (a, b);
}

IndexTaskMap * m6 blockwise;
IndexTaskMap task_1 m4 block2d;
IndexTaskMap task_2 m4 block2d;
IndexTaskMap task_3 m4 block2d;
IndexTaskMap init_cublas m7 block1d;
