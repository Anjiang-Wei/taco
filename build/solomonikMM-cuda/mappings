Task * GPU,OMP,CPU;

Region * * * SOCKMEM,SYSMEM;
Region * * GPU FBMEM,ZCMEM;

# Layout taskname regionname memory AOS F_order;
Layout * * * SOA C_order; # Exact Align==128 Compact

# InstanceLimit task_1 OMP 10; # controlled by command line in TacoMapper

CollectMemory * *;

def block_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2) {
    return x[dim1] * z.size[dim2] / y.size[dim1];
}

def cyclic_primitive(IPoint x, ISpace y, MSpace z, int dim1, int dim2) {
    return x[dim1] % z.size[dim2];
}

m4 = Machine(GPU); # nodes * processors
m7 = m4.merge(0, 1);

def single_func(Task task) {
    return m4[*task.parent.processor(m4)]; # same point as parent
}

def block1d(Task task) {
    return m7[block_primitive(task.ipoint, task.ispace, m7, 0, 0)];
}

def block2d(Task task) {
    indices = tuple(block_primitive(task.ipoint, task.ispace, m4, i, i) for i in (0, 1));
    # m4 = m4.swap(0, 1);
    return m4[*indices];
}

def new_func(Task task) {
    m5 = m4.auto_split(0, task.ispace); # split the original 0 dim into 0,1,2 dim
    # m5 = m5.swap(0, 2); # swap works for node=4, but not node=2
    z = m5.auto_split(3, task.ispace); # split the original 1 (now 3) dim into 3,4,5 dim
    upper = tuple(block_primitive(task.ipoint, task.ispace, z, i, i) for i in (0,1,2));
    lower = tuple(cyclic_primitive(task.ipoint, task.ispace, z, i, i + 3) for i in (0,1,2));
    return z[*upper, *lower];
}

# 2nodes: rpoc=2 c=2 
# 4nodes: rpoc=4, c=1
# 8nodes: rpoc=4 c=2
# 16nodes: rpoc=8 c=1

SingleTaskMap task_4 single_func;
IndexTaskMap task_5 new_func; # task_5: (rpoc, rpoc, c)
IndexTaskMap task_1,task_2, task_3 block2d; # task_1, task_2, task_3: (rpoc, rpoc, 1), has PLACE_SHARD tag
IndexTaskMap init_cublas block1d;
